-----------------------------------------------------------
    Making HTTP Requests from JavaScript
-----------------------------------------------------------
---Introduction
XMLHttpRequest:
- one of the browser APIs that provide network programming functionality to JavaScript applications
- libraries or utility functions often wrap this web API

---Network Programming in JavaScript
Page Navigation: user clicks link in a page -> browser sends HTTP request to server -> server returns entire HTML page -> browser parses and displays new page
- When a user clicks a link, the web browser automatically requests the page
- When the browser receives a response, it renders it in the viewport

AJAX: Asynchronous JavaScript and XML
- provides a way to replace only part of a web page instead of reloading an entire HTML page

Two ways how AJAX differs from the page-navigation example above:
1. The web browser doesn't make an automatic HTTP request; instead, JavaScript code initializes it, typically from an event listener
2. When the browser receives a response, JavaScript code takes the response's body and updates the pgae as needed

#When requesting a resource using JavaScript, the developer must write code that initiates the request and handles the response#

AJAX Flow: user action triggers event listener -> JavaScript sends HTTP request to server using XMLHttpRequest -> server returns chunk of HTML code -> JavaScript code inserts new HTML into page

Single Page Applications:
- modern applications that fetch data in a serialized format and create the DOM entirely from JavaScript running in a client's browser
- instead of fetching bits of HTML generated by a server, this model does all interactions by passing data to and from the server, often encoded as JSON

---Making a Request with XMLHttpRequest
XMLHttpRequest:
- object used to send a HTTP request with JavaScript
- part of the browser API, not the JavaScript language
- name comes from original use, which was to fetch XML documents over HTTP
- today, typically loads HTML or JSON and can use other protocols

[js]
var request = new XMLHttpRequest(); // Instantiate new XMLHttpRequest object
request.open('GET', '/path');       // Set HTTP method and URL on request
request.send();                     // Send request
[\js]

`request.send` is asynchronous, so code execution continues without waiting for it to complete.

Become familiar with the following `XMLHttpRequest` methods:
- `open(method, url)`: Open a connection to url using method
- `send(data)`: Send the request, optionally sending along data
- `setRequestHeader(header, value)`: Set HTTP header to value
- `abort()`: Cancel an active request
- `getResponseHeader(header)`: Return the response's value for header

Become familiar with the following `XMLHttpRequest` properties:
- `timeout`: Maximum time a request can take to complete (in milliseconds)
- `readyState`: What state the request is in (see below)
- `responseText`: Raw text of the response's body
- `response`: Parsed content of response, not meaningful in all situations

---XMLHttpRequest Events
To run some code when an event occurs on an `XMLHttpRequest` object, we can use the same `addEventListener` method that we use for handling user or page events.

Two main events fire during an `XMLHttpRequest` cycle:
1. `loadstart`: Request sent to server
2. `loadend`: Response loading done and all other events have fired. Last event to fire.

Before `loadend` triggers, another event will fire based on whether the request succeeded:
- `load`: A complete response loaded
- `abort`: The request was interrupted before it could complete
- `error`: An error occurred
- `timeout`: A response wasn't received before the timeout period ended

Keep in mind that a browser considers any request that receives a complete response as successful, even if the response has a non-200 status code or represents an application error.
#Whether `load` or another event fires is determined by whether the HTTP request-response cycle loads a complete response. It does not consider the response's semantic meaning to the application.
It is the responsibility of the application code to determine whether a `request` was successful from its perspective by inspecting the response within a `load` event handler.

---Data Serialization
- JavaScript applications that run in a web browser must *serialize* data when communicating with remote systems
- Serialization lets both the client and server transfer data in a format that preserves information without interfering with the communication protocol
- URL encoding for query strings is a common serialization format
- JavaScript provides a built-in function, `encodeURIComponent`, that lets you encode a name or value using URL encoding
- You can append a properly encoded query string to a GET request's path
- URL encoding also works with POST requests, but you must include a `Content-Type` header with a value of `application/x-www-form-urlencoded` and place the encoded name-value string in the request body

- For forms that include file uploads or that use `FormData` objects to collect data, POST requests use multipart form formats
- This format isn't strictly an encoding format since we don't encode anything
- Each name-value pair is placed in a separate section of the request body
- A *boundary delimiter* defined by the `Content-Type` request header separates each part:
`Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywDbHM6i57QWyAWro`

JSON (JavaScript Object Notation):
- a popular format used by APIs
- can exchange arrays, objects, strings, numbers, and boolean values over the network
- does not provide native support for complex data types like dates and times
- a `GET` request can return JSON, but you must use `POST` to send JSON data to the server
- to use JSON as the request serialization format, the `Content-Type` is required to have a value of `application/json; charset=utf-8` (the `charset` is optional)

---Example: Loading HTML via XHR
- We can use an `XMLHttpRequest` object to fetch  content and insert it in an existing web page without a full page reload
- We can attach event listeners to content embedded in the page to circumvent the browser's default behavior and create custom interactions

---Example: Submitting a Form via XHR
Three steps to submitting a form using JavaScript:
1. Serialize the form data
2. Send the request using `XMLHttpRequest`
3. Handle the response

`FormData`:
- a built-in API to assist in the process of URL-encoding the names and values of each `input` element
- makes it easy to serialize a form's data
- `FormData` uses the *multipart* format

---Example: Loading JSON via XHR
- the `responseType` property tells the browser how to handle the data it receives
- valid values for `responseType`: `text`, `json`, `arraybuffer`, `blob`, and `document`
- setting `responseType` lets us avoid extra error-handling code that we may need using `JSON.parse`

---Example: Sending JSON via XHR
Same three steps as submitting a form, but with a couple of adjustments:
1. Serialize the data *into valid JSON*
2. Send the request using `XMLHttpRequest` *with a* `Content-Type: application/json` *header*
3. Handle the response

---Cross-Domain XMLHttpRequests with CORS
- the scheme, hostname, and port of a URL define its origin
- a cross-origin request occurs when the page tries to access a resource from a different origin
- a cross-domain request is a request from one domain (hostname) to another domain
- by default, an `XHR` object can't send cross-origin requests because of security problems
- all browsers implement a security feature called the same-origin policy

CORS - Cross-Origin Resource Sharing:
- a W3C specification that defines how the browser and server must communicate when accessing resources across origins
- the idea is to let the two systems know enough about each other to determine whether the response should succeed or fail
- applications use custom HTTP request and response headers to implement this mechanism
- every `XMLHttpRequest` sent by the browser must have an `Origin` header that contains the origin of the requesting page
- the server uses this header to determine whether it should send a corresponding header in the response
- the browser automatically adds the `Origin` header as part of an `XHR`
- if the server determines the origin is allowed to see the response, it sends the response with an `Access-Control-Allow-Origin` header that contains the same origin
- even if the server sends the correct response, but without the `Access-Control-Allow-Origin` header with the appropriate value, the browser will raise an error

---Project: Search Autocomplete, Part 5 - Throttling XHR requests
Making requests that you don't need is bad practicel; it puts a huge strain on the server, which is a huge concern in a production environment.

Throttling:
- waits for some specified time before sending a request to the server
- if, in the interim, that request becomes irrelevant due to a newer request, we discard the original request and start a new delay period for the newer request
- many JS libraries provide this capability, often with a funciton named `debounce`

Custom version of `debounce`:
[js]
function debounce(func, delay) {
  var timeout;

  return function() {
    var args = arguments;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      func.apply(null, args);
    }, delay);
  };
}
[\js]

By using `debounce`, we dramatically reduce the number of AJAX requests sent by our application.