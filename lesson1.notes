-----------------------------------------------------------
    The DOM
-----------------------------------------------------------
---The Document Object Model (DOM)
DOM: an in-memory object representation of an HTML document. It provides a way to interact with a web page using JavaScript and provides functionality needed to build modern interactive user experiences.

---A Hierarchy of Nodes
Browsers insert possibly missing elemets like `HEAD` and `BODY` since a fundamental tenet of the web is permissiveness; they always do their best to display HTML even when it has errors.

DOM nodes have different types:
- Elements represent HTML tags
- Text nodes represent text that appears in the document
- Comments represent the HTML comments
- (The DOM includes some other types that we can ignore for now)

Empty nodes: text nodes that only contain whitespace (e.g., the gap between `</h1>` and `<p>` forms an empty node that contains a newline and two space characters). Developers often forget about these empty nodes since they aren't visible in the HTML, which can lead to bugs. Empty nodes are *not* reflected visually in the browser.

---Node Properties
`querySelector`: This method returns the first node in the DOM that matches a specified CSS selector.

The `document` node, which represents the entire HTML document, is the top-most DOM node.

Using `toString` is a handy way to determine an object's type.

`nodeName`: property that contains a String that represents the node type.
- For Elements (anything that represents an HTML tag), this is the name of the corresponding tag in uppercase. The use of uppercase is a historical throwback to a time when standard practice was to write uppercase HTML tags; contemporary HTML uses lowercase tags, but this method still returns uppercase names.
- For text nodes -- even empty nodes -- the nodeName is "#text". For comments, it's "#comment".

`nodeType`: can use to determine a node's type: returns a number that matches a node type constant.
- ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, DOCUMENT_NODE = 9, etc.
- Use the constant names instead of the numeric values to write clear code

`nodeValue`: references the value of a node.
- Element nodes don't have values (return null)
- Text nodes return the textual content of the node

`textContent`: represents the textual content of all nodes inside the Element.

---Determining the Type of a Node
The Element type is further broken down into dozens of subtypes:
- All DOM objects are Nodes
- All DOM objects have a type that inherits from Node
- The most common DOM object types you will use are Element and Text

. Event Target
  . Node
    . Text
    . Comment
    . Document
      .HTMLDocument
    . Element
      . HTMLElement
        . HTMLAnchorElement
        . HTMLBodyElement
        . etc.
      . SVGElement
        . SVGColorElement
        . SVGRectElement
        . etc.

JavaScript provides two useful ways to determine a node type:
1. The technique most useful on the console uses the `toString` method or the `String` constructor on the node; you can read the name from the display
2. If you're writing a program, you should probably use the `instanceof` function or `tagName` property.

---Traversing Nodes
You should know these properties of parent nodes:
- `firstChild`: `childNodes[0]` or `null`
- `lastChild`: `childNodes[childNodes.length - 1]` or `null`
- `childNodes`: *Live collection* of all child nodes (a live collection automatically updates to refelct changes in the DOM)

You should know these properties of child nodes:
- `nextSibling`: `parentNode.childNodes[n + 1]` or `null`
- `previousSibling`: `parentNode.childNodes[n - 1]` or `null`
- `parentNode`: Immediate parent of this node

Recursive `walk` function by LS:
[js]
  function walk(node, callback) {
    callback(node);
    var i;
    for (i = 0; i < node.childNodes.length; i++) {
      walk(node.childNodes[i], callback);
    }
  }

  walk(document.body, function(node) {
    console.log(node.nodeName);
  });
[\js]

---Element Attributes
We can access the attributes of an Element using these methods:
- `getAttribute(name)`
- `setAttribute(name, newValue)`
- `hasAttribute(name)`

`getAttribute` and `setAttribute` work for all attributes, but you can access some attributes another way.
The DOM exposes these special attributes as properties of the Element: `id`, `name`, `title`, `value`, and `className`.

Working with the `class` attribute via `className` is inconvenient when elements have more than one class.
The `classList` property references a special array-like `DOMTokenList` object that has these properties and methods:
- `add(name)`: Add class name to element
- `remove(name)`:  Remove class name from element
- `toggle(name)`:  Add class name to element if it doesn't exist, remove if it does exist
- `contains(name)`:  Return true or false depending on whether element has class name
- `length`:  The number of classes to which element belongs

The `style` attribute on an Element references a `CSSStyleDeclaration` Object, and can be used to alter any CSS property.
When a CSS property's name contains dashes, you must use a camelCased version of the name to access that property.

---Finding DOM Nodes
The built-in method `getElementById` on `document` allows us to find an element based on its `id` attribute.

However, we more often want all elements that match some criteria.

#LS provides some practice problems to manually get all elements that match a certain criteria#

These built-in methods provide a way to get collections of elements that meet a certain criteria:
- `document.getElementsByTagName(tagName)`: returns `HTMLCollection` or `NodeList` of matching elements
- `document.getElementsByClassName(className)`: returns `HTMLCollection` or `NodeList` of matching elements

Note that these methods return array-like objects, not actual arrays. To loop through the elements returned by these methods, use a `for` loop or convert the object into an array and then use the higher-order array functions.

Web browsers provide built-in support for selector searches with these two methods:
1. `document.querySelector(selectors)`: returns first matching element or `null`
2. `document.querySelectorAll(selectors)`: returns `NodeList` of matching elements
- Learn to use these methods; they will save you a lot of time.
- Note that both these methods are available on all elements, not just `document`.

---Traversing Elements
Earlier, we looked at some properties that you can use to traverse DOM nodes.
However, there is another set of properties that allows you to traverse element nodes...
Parent Element Properties:
- `firstElementChild`: `children[0]` or `null`
- `lastElementChild`: `children[children.length - 1]` or `null`
- `children`: *Live collection* of all child elements
- `childElementCount`: `children.length`

Child Element Properties:
- `nextElementSibling`: `parentNode.children[n + 1]` or `null`
- `previousElementSibling`: `parentNode.children[n - 1]` or `null`

The `textContent` property provides access to the text:
- #Be careful# when setting `textContent`; doing so removes all child nodes from the element and replaces them with a text node that contains the value.
- The best strategy for updating text with JavaScript is to place the text you need to update within an element; the element type doesn't matter -- even a bare `span` or `div` element will suffice. This approach makes using `textContent` simpler and safer to use.

---Creating and Moving DOM Nodes
You can create new empty nodes with the `document.create*` methods, or you can clone an existing node hierarchy:
- `document.createElement(tagName)`: Returns a new Element node
- `document.createTextNode(text)`: Returns a new Text node
- `node.cloneNode(deepClone)`: Returns a copy of `node`
  - If `deepClone` is `true`, `cloneNode` makes copies of `node` and *all its children*; otherwise, it merely copies `node`
  - The default value for `deepClone` has changed over time, so always specify `true` or `false`
  - The clone creates a new object -- changing one does not change the other

You can append, insert, and replace nodes with methods on the node's parent:
- `parent.appendChild(node)`: Append `node` to the end of `parent.childNodes`
- `parent.insertBefore(node, targetNode)`: Insert `node` into `parent.childNodes` before `targetNode`
- `parent.replaceChild(node, targetNode)`: Remove `targetNode` from `parent.childNodes` and insert `node` in its place

`document.appendChild` causes an error. Use `document.body.appendChild` instead.

#No Node may appear twice in the DOM#. If you try to add a node that is already in the DOM, it gets removed from the original location.

These methods insert a node before, after, or within an Element:
- `element.insertAdjacentElement(position, newElement)`: Inserts `newElement` at `position` relative to `element`
- `element.insertAdjacentText(position, text)`:  Inserts Text node that contains `text` at `position` relative to `element`

`position` must be one of the following `String` values:
- "beforebegin": Before the element
- "afterbegin": Before the first child of the element
- "beforeend":After the last child of the element
- "afterend": After the element

When you remove a node from the DOM, it becomes eligible for garbage collection unless you keep a reference to the node in a variable:
`node.remove()`: Remove `node` from the DOM
`parent.removeChild(node)`: Remove `node` from `parent.childNodes`

---The Browser Object Model (BOM)
You can access other components of the browser with JavaScript that go beyond the page contents. These components include:
- The windows used to display web pages
- The browser's history
- Sensors, including location
