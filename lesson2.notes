-----------------------------------------------------------
    Event-Driven and Asynchronous Programming
-----------------------------------------------------------

---Asynchronous Execution with setTimeout
Sequential code: for each line of code, the next line of code must wait until the current line completes.
Asynchronous code: runs partly now, then pauses and continues to run later after a delay of milliseconds, minutes, hours, or even days.

`setTimeout`:
- a function that takes two arguments: a callback function and a time to wait specified in milliseconds
- It sets a timer that waits until the given time delay elapses, then invokes the callback function
- No other code executes until the delay time elapses, then the callback function runs as expected

Ultimately, working with asynchronous code means you must reason about both *what* the code does and *when* it does it.

---Repeating Execution with setInterval
`setInterval`:
- Instead of invoking the callback once, it invokes it again and again at intervals until told to stop
- returns an identifier that we can later pass to `clearInterval` to cancel the timer and stop the repeated execution of the callback

---User Interfaces and Events
Event:
- an object that represents some occurrence; it contains information about what happened and where it happened
- the browser can trigger events as the page loads, when the user interacts with the page, and when the browser performs some action required by the program

The code within a user interface has two main tasks:
1. Set up the user interface and display it
2. Handle events resulting from user or browser actions

Event listener: code that the browser runs in response to the event.

---Page Lifecycle Events
The (simplified) steps a browser goes through to load a page:
HTML code received from server -> HTML parsed and JavaScript evaluated -> DOM constructed from parsed HTML -> `DOMContentLoaded` event fires on `document` -> Page displayed on screen -> Embedded assets are loaded -> `load` event fires on `window`

- We typically use the `DOMContentLoaded` event when we have JavaScript code that must access the DOM.
- The `load` event fires much later, after everything on the page loads, including images, videos, etc. This `load` event is not useful in mose cases because it may not occur for a long time after the page first appears.

---User Events
Keyboard: keydown, keyup, keypress
Mouse: mouseenter, mouseleave, mousedown, mouseup, click
Touch: touchdown, touchup, touchmove
Window: scroll, resize
Form: submit
#This is not an exhaustive list#

Keep in mind that an event's type determines the kind of code it makes sense to run within an event handler, but registering and triggering events is the same for all.

---Adding Event Listeners
There are four steps needed to setup an event listener (handler):
1. Identify the event you need to handle.
2. Identify the element that will receive the event.
3. Define a function to call when this event occurs.
4. Register the function as an event listener.

We can call `addEventListener` on the object to which we want to register the listener.

#The `GlobalEventHandlers` mixin provides an alternate way to register a function as an event listener for an element.#

---The Event Object
Useful properties that appear in Event objects include:
`type`: The name of the event (e.g., 'click')
`currentTarget`: The current object that the event object is on. It always refers to the element that has the event listener attached to it
`target`: The initial object to receive notification of the event, e.g., the element clicked by the user

Mouse Events:
`button`: This is a read-only property that indicates which button was pressed
`clientX`: The horizontal position of the mouse when the event occurred
`clientY`: The vertical position of the mouse when the event occurred
- Both `clientX` and `clientY` return values *relative to the visible area of the page*: the number of pixels from the upper-left corner of the browser's viewport

Keyboard Events:
`key`: The string value of the pressed key. *Older browsers do not support this property*
`shiftKey`: Boolean value that indicates whether the user pressed the shift key
`altKey`: Boolean value that indicates whether the user pressed the alt (or option)
`ctrlKey`: Boolean value that indicates whether the user pressed the control key
`metaKey`: Boolean value that indicates whether the user pressed the meta (or command) key

---Capturing and Bubbling
There are downsides to having event listeners attached to each element of interest on the page:
- you must wait until the `DOMContentLoaded` event fires
- you must add event handlers manually when you add new elements to the page after `DOMContentLoaded` fires
- adding handlers to many elements can be slow, and can lead to complicated, difficult to maintain code

A technique called *event delegation* provides a solution for these problems, but before we can learn how to use it, we first need to talk about *capturing* and *bubbling*.

*Capturing* and *bubbling*:
- phases that an event goes through after it initially fires
- the event gets dispatched to each element twice, once during the capturing phase and once during the bubbling phase
- the actual event listener gets called/fired in only one phase
- by default the listener is set to fire during the "bubbling" phase
- when event listeners fire on the target element it is also described as the *target phase*

---Preventing Propagation and Default Behaviors
- `event.stopPropagation`: stops the `event` from continuing its path along the capturing and bubbling phases
- `event.preventDefault`: tells the browser that it shouldn't perform any actions that it might otherwise perform in response to a user's action

It's good practice to call `preventDefault` or `stopPropagation` as soon as possible in an event handler:
- emphasizes the presence of those methods to people reading the code
- ensures that these methods run before any errors occur; not running these methods before and error occurs can lead to unexpected behavior that is hard to debug

Important observations about `preventDefault`:
1. The default behavior isn't for the element that the event listener is attached to, but rather for the `event` object.
2. The browser waits for the event object to go through the propagation phases (capturing and bubbling) before it performs the default action of the event. If there's an event handler with a `preventDefault` call somewhere in the propagation path, the default behavior is skipped.

Default behavior can still happen even if one of the listeners had a call to `preventDefault`:
`event.stopPropagation` stops the event object from heading to a next listener which might contain a `preventDefault` method call. Consequently, `event.preventDefault` is never called and the default behavior is allowed to happen.

---Event Delegation
- Instead of adding listeners to every element you're watching, you can add a single handler to any of their parents.
- You don't have to wait until the DOM is ready if you are able to add the event listener directly to `document` because it is available to start with.
- The trade-off of delegation is that the listener may become more complicated if it must handle multiple situations.
- The best approach is to start by binding event handlers directly to elements when a project is new and small.
- jQuery, which we'll look at in an upcoming lesson, includes functionality that makes delegation comparatively easy whil avoiding the complexity drawback.

---What is the Event Loop?
















































---What is the Event Loop?
What the heck is the event loop anyway (video by Philip Roberts):
- link: https://www.youtube.com/watch?v=8aGhZQkoFbQ

JavaScript:
- a single-threaded, non-blocking, asynchronous, concurrent langauge
- has a call stack, an event loop, a callback queue, and other APIs

V8 (Chrome's runtime):
- has a call stack and a heap

The call stack:
- one thread == one call stack == one thing at a time
- basically a data structure which records where in the program we are
- stack trace is the state of the call stack when an error occurs

Blocking (what happens when things are slow?):



